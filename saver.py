import matplotlib.pyplot as plt
import os
import torch

class Saver:
    def __init__(self, save_dir, val_acc=True):
        self.save_dir = save_dir
        self.losses_per_10_batches = []        # [epoch, loss sample every 10 batches]
        self.losses = []        # [epoch]
        self.val_accs = []      # [epoch]
        self.val_acc = val_acc
        os.makedirs(save_dir, exist_ok=True)
        os.makedirs(os.path.join(save_dir, 'checkpoints'), exist_ok=True)
        
        with open(os.path.join(self.save_dir, 'log.txt'), 'w') as f:
            f.write("")   # Clear previous log

    def save_model(self, model, name):
        torch.save(model.state_dict(), os.path.join(self.save_dir, 'checkpoints', name))
        print(f"Model saved to '{os.path.join(self.save_dir, 'checkpoints', name)}'")

    def plot_loss_accuracy_curve(self):     # This plot function generated by Gemini 2.5 flash
        # Create a figure and a primary axes object
        fig, ax1 = plt.subplots(figsize=(10, 5))

        # Plot the training loss on the primary axes
        color = 'tab:blue'
        ax1.set_xlabel('Epoch')
        ax1.set_ylabel('Loss', color=color)
        ax1.plot(self.losses, label='Train Loss', color=color)
        ax1.tick_params(axis='y', labelcolor=color)
        ax1.legend(loc='upper left')

        # Plot the validation accuracy on the secondary axes
        if self.val_acc:
            # Create a second axes object that shares the same x-axis
            ax2 = ax1.twinx()
            
            color = 'tab:orange'
            ax2.set_ylabel('Accuracy', color=color)
            ax2.plot(self.val_accs, label='Validation Accuracy', color=color)
            ax2.tick_params(axis='y', labelcolor=color)
            ax2.legend(loc='upper right')

            # Find the index and value of the best validation accuracy
            best_acc_value = max(self.val_accs) if self.val_accs else 0
            best_acc_epoch = self.val_accs.index(best_acc_value)

            # Highlight the best validation accuracy point with a red marker
            ax2.plot(best_acc_epoch, best_acc_value, 'ro', markersize=10, label=f'Best Accuracy: {best_acc_value:.4f}')

        # Set the title and layout
        plt.title('Training Loss and Validation Accuracy Curve' if self.val_acc else 'Training Loss Curve')
        fig.tight_layout()

        # Save the figure to the specified directory
        plt.savefig(os.path.join(self.save_dir, 'loss_accuracy_curve.png' if self.val_acc else 'loss_curve.png'))
        plt.close(fig)
        print(f"Plot saved to '{os.path.join(self.save_dir, 'loss_accuracy_curve.png' if self.val_acc else 'loss_curve.png')}'")

    def saver_step(self, loss, log):       # Call every 10 batches
        if len(self.losses_per_10_batches) == 0:
            self.losses_per_10_batches.append([])
        self.losses_per_10_batches[-1].append(loss)
        with open(os.path.join(self.save_dir, 'log.txt'), 'a') as f:
            f.write(log)

    def saver_epoch(self, avg_loss, val_acc=None):      # Call once per epoch
        self.losses.append(avg_loss)
        self.losses_per_10_batches.append([])   # Prepare for next epoch
        if val_acc is not None:
            self.val_accs.append(val_acc)
        self.plot_loss_accuracy_curve()